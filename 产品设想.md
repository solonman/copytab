### **最终版“CopyTab”说明**

**角色 (Role):**
你是一位顶级的全栈软件架构师和AI产品经理，精通利用现代技术栈（如 Supabase 和 AI 大语言模型）快速构建功能丰富、用户体验卓越的SaaS应用程序。

**任务 (Task):**
为一款名为“**CopyTab**”的在线广告文案写作工具，提供一份完整的技术实现蓝图。该蓝图应包含详细的功能分解、UI/UX设计风格、前后端技术架构、数据库设计、以及关键功能（尤其是AI补全、离线同步和分享）的核心实现逻辑。**特别注意：必须将用户写作时的流畅体验作为最高优先级，为补全建议的毫秒级响应设计专门的性能优化策略。** 这份文档是项目的唯一真实来源，必须包含所有必要的细节，以指导从设计到开发的全过程。

**应用总览 (Application Overview):**

*   **应用名称:** CopyTab
*   **核心理念:**
    1.  **效率核心:** 将AI编程工具中高效的“代码补全”体验，创新性地应用于广告文案写作。
    2.  **告别重复:** 自动化处理文案中的标准信息，如品牌Slogan、产品规格、公司地址、活动价格等，将文案人员从重复性劳动中解放出来。
    3.  **灵活智能:** 提供两种补全模式，兼顾信息必须准确的“逐字模式”和需要创意发挥的“改写模式”。
    4.  **无缝同步:** 通过云端与本地同步机制，实现跨设备无缝写作和离线操作能力。

**UI/UX设计与页面风格 (UI/UX Design & Page Style)**

*   **核心灵感:** 视觉风格和用户体验应严格参考 **`aistudio.google.com`**，打造一个明亮、干净、功能驱动、具有专业感的工具界面。
*   **主题:** **明亮模式 (Light Mode)**。整个界面以白色和浅灰色为基调，强调内容的清晰度、可读性和功能的可发现性。
*   **色彩方案:**
    *   **主背景:** 使用纯白色 (`#FFFFFF`) 或非常浅的、几乎感觉不到的灰色 (`#F8F9FA`)，营造开阔、干净的画布感。
    *   **区隔背景:** 对于侧边栏、设置面板等二级区域，使用稍深的灰色（如 `#F1F3F4`）来与主内容区进行柔和的区分。
    *   **活动/悬停状态:** 列表中的活动项或鼠标悬停项，使用更深一点的灰色背景（如 `#E8EAED`）提供清晰的视觉反馈。
    *   **强调色:** 采用Google的标志性蓝色（如 `#1A73E8`）作为所有可交互元素的主色调，包括按钮、链接、输入框的焦点边框、活动状态的图标和下划线等。
    *   **文本颜色:** 主体文本使用近乎黑色的深灰色 (`#202124`) 以保证最佳对比度和可读性。辅助性文本、标签或占位符使用中度灰色 (`#5F6368`)。
*   **排版:**
    *   **字体:** 采用Google的官方字体，如 Google Sans (用于标题和UI元素) 和 Roboto (用于长篇正文)，确保跨平台的视觉一致性和卓越的易读性。
    *   **层级:** 严格通过字重 (Font Weight: Regular, Medium, Bold) 和字号 (Font Size) 的组合，建立清晰的视觉信息层级。例如，页面标题(H1)应显著，而卡片标题(H2/H3)则次之。
*   **布局与间距:**
    *   **功能性布局:** 采用经典的三栏式或两栏式布局。左侧为固定的主导航栏（包含项目列表和设置入口），中间为宽敞的主要工作区（文本编辑器），右侧可根据需要滑出，作为上下文相关的设置面板（如文档信息、导出选项、分享设置）。
    *   **呼吸空间:** 严格遵循8px网格系统，所有元素之间的间距（padding 和 margin）都应是8的倍数。这能创造出有条不紊、不拥挤、视觉上令人舒适的界面。
*   **组件风格:**
    *   **按钮:** 遵循Material Design规范。主要操作（Call-to-Action）使用蓝色填充的圆角矩形按钮。次要操作使用描边按钮。其他操作则使用无边框的纯文本按钮，以减少视觉干扰。
    *   **输入框与控件:** 输入框具有清晰的浅灰色边框（`#DADCE0`），在获得焦点时，边框会变为2px的蓝色。开关（Toggles）、滑块（Sliders）、下拉菜单等表单控件，都应具有明确的视觉状态（开启/关闭，选中/未选中）。
    *   **图标:** 统一使用Google Material Icons图标库，确保所有图标风格一致、表意清晰。
    *   **卡片与分割线:** 使用带有非常浅的灰色边框和轻微圆角（4-8px）的卡片来组织信息块。使用1px的细微分割线（`#DADCE0`）来区隔不同的功能模块。
    *   **新增UI元素:**
        *   **全局改写模式开关:** 在写作界面的顶部工具栏或右侧设置面板中，放置一个清晰的开关（Toggle）控件，标签为“启用改写模式”。
        *   **跟随式浮动按钮:** 一个小巧、非侵入式的圆形按钮，内含“魔法棒”或类似图标。当满足触发条件时，它会平滑地出现在补全文字的右侧或下方。

**用户旅程 (User Journey):**

1.  **注册与登录 (Onboarding):** 新用户通过简洁的表单，使用邮箱或一键式社交账号（Google）注册。登录后，若为首次使用，会有一个简短的引导提示其创建第一个项目。
2.  **创建项目 (Project Creation):** 用户进入仪表盘，点击醒目的“新建项目”按钮。在弹出的模态框中，输入项目名称（例如“2025年夏季新品推广”），完成创建。
3.  **构建知识库 (Knowledge Base Setup):**
    *   **a. 添加标准条目 (用于逐字补全):** 用户进入“知识库”->"条目管理"。点击“添加新条目”，在表单中输入需要**绝对精确**的内容，如公司地址、电话号码、法律声明等。这些条目将始终用于逐字补全。
    *   **b. 上传知识文档 (用于改写补全):** 用户切换到“知识库”->"文档管理"。点击“上传文档”，可以粘贴大段文本或上传文件（.txt, .md）。这些文档包含了品牌故事、产品介绍、市场策略等丰富但非结构化的信息。**系统在后台会自动对文档进行分析、分块、提取关键信息并建立索引**，为后续的改写模式提供素材。
4.  **开始写作 (Writing & Creation):** 用户在项目中新建一篇文稿，进入一个沉浸式的、无干扰的写作界面，并根据需要设置“全局改写模式”的开关状态。
5.  **核心功能使用 (Core Feature Engagement):**
    *   **场景一 (改写模式开启):** 用户输入时，如果内容与“标准条目”匹配，则进行逐字补全。如果与“知识文档”内容更相关，系统会提供**AI生成和改写后**的补全建议。
    *   **场景二 (改写模式关闭):** 任何情况下，`Tab`补全都只进行**逐字补全**（无论是匹配到标准条目还是文档原文片段）。但如果补全内容来源于“知识文档”，在补全后，旁边会**立即出现一个“改写”浮动按钮**，用户可以点击它来对刚刚插入的内容进行风格变换。
6.  **输出与协作 (Output & Collaboration):** 文稿完成后，用户点击右上角的“导出”按钮，选择所需格式下载文件。或点击“分享”按钮，系统生成一个唯一的URL，用户可以将其复制并发送给同事或客户进行审阅。

**详细功能需求 (Detailed Functional Requirements):**

**1. 知识库构建 (Knowledge Base Construction):**
*   **a. 条目式输入 (Itemized Entry):**
    *   **UI:** 简洁的表单，包含“内容”文本区和可选的“类别”标签。
    *   **后端:** 用户提交后，数据直接存入`standard_info`表中。这些条目将被用于高优先级的精确匹配。
*   **b. 文档式上传与处理 (Document Upload & Processing - RAG流程):**
    *   **UI:** 一个支持文本粘贴和文件上传的界面。
    *   **后端 (RAG流程):**
        1.  **解析与分块 (Parse & Chunk):** 接收到文档后，系统首先将其按逻辑（如段落、标题）或固定长度分割成更小的、有意义的文本块 (Chunks)。
        2.  **向量化 (Vectorize):** 对每一个文本块，调用文本嵌入模型（如Google's `text-embedding-004`）生成向量表示（Vector Embedding）。
        3.  **存储与索引 (Store & Index):** 将文本块原文及其对应的向量，存储在专门的PostgreSQL表中，并利用 `pgvector` 扩展建立高效的向量索引。这张表（例如`document_chunks`）由系统在后台管理。

**2. 全局改写模式与`Tab`键补全逻辑:**
*   **后端补全请求处理流程（三级优先级）：**
    1.  **第一优先级：精确匹配** `standard_info`表（知识库标准信息）。
    2.  **第二优先级：语义匹配** `document_chunks`表（知识库文档内容）。
    3.  **第三优先级：通用补全** 基于AI模型的智能文本补全（通用写作辅助）。
*   **通用补全功能说明：**
    *   **功能定位：** 当用户输入的内容与知识库无关时，系统提供基于AI的通用文本补全建议，帮助用户流畅完成广告文案写作。
    *   **触发条件：** 当前两级知识库匹配均未找到合适内容时，自动触发通用补全。
    *   **补全类型：**
        *   **语法补全：** 完成句子结构，如"我们的产品不仅..." → "我们的产品不仅能够满足您的基本需求"
        *   **营销用语补全：** 提供专业的营销词汇和短语，如"限时..." → "限时优惠，先到先得"
        *   **创意表达补全：** 为平淡的描述增加创意元素，如"质量很好" → "质量卓越，经得起时间的考验"
        *   **上下文衔接补全：** 基于前文内容提供逻辑连贯的下文建议
    *   **个性化学习：** 系统会学习用户的写作风格和偏好，随着时间推移提供更符合个人风格的补全建议。
*   **a. 当全局"改写模式"开启时:** 
    *   精确匹配返回原文（知识库标准信息）
    *   语义匹配调用LLM生成改写建议（知识库文档内容）
    *   通用补全提供AI生成的创意性文本建议
*   **b. 当全局"改写模式"关闭时:** 
    *   所有匹配都返回**原文**或基础补全建议
    *   语义匹配和通用补全会额外返回一个标志位，用于前端显示"改写"浮动按钮
*   **c. 跟随式浮动按钮"改写"功能:** 点击后，前端发送当前文本到后端，后端调用LLM进行改写并返回结果。按钮可重复点击以实现无限次改写。

**3. 性能优化与流畅体验保障策略 (Performance Optimization & Fluency Strategy):**
*   **目标:** 确保补全建议（灰色文字）的出现是**毫秒级**的，用户在输入时绝不会感到延迟或卡顿。
*   **实现策略:**
    *   **a. 前端优先原则 (Frontend-First Caching):**
        *   **离线知识库:** 当用户打开一个项目进行写作时，**将该项目所有“条目式输入”的 `standard_info` 数据完整加载到浏览器内存或IndexedDB中**。
        *   **本地匹配:** “逐字补全”的匹配逻辑**完全在前端执行**。这样，当用户输入时，无需任何网络请求，匹配和建议显示可以在`~1ms`内完成，实现绝对流畅。
    *   **b. 智能请求管理 (Intelligent Request Handling):**
        *   **防抖机制 (Debouncing):** 前端不会在用户每次按键时都发送请求。而是设置一个短暂的延迟（例如 `200ms`）。只有当用户停止输入超过这个时间，才会触发一次后端请求（仅针对需要语义搜索的场景）。
        *   **请求取消 (Request Cancellation):** 如果用户在防抖延迟期间继续输入，前一个待发送的请求将被取消。如果请求已发送但用户又开始输入，前端应使用 `AbortController` 等机制取消上一次的网络请求。
    *   **c. 后端分层响应 (Tiered Backend Response for Rewrite Mode):**
        *   **承认LLM延迟:** 调用LLM进行生成式改写**不可能**在毫秒级完成。
        *   **两阶段建议 (Two-Stage Suggestion):**
            1.  **第一阶段 - 快速返回原文:** 后端的向量搜索本身非常快。当“改写模式”开启并匹配到文档知识时，后端**立即返回匹配到的原始文本块**作为第一版建议。
            2.  **第二阶段 - 异步生成改写:** 在返回原文的同时，后端**异步地**将原文和上下文发送给Gemini模型进行改写。
            3.  **无缝更新建议:** 当Gemini返回了更优的改写结果后，如果用户的光标仍然停留在该建议的末尾，前端可以将灰色文字**平滑地更新**为这个新的、更智能的建议。
    *   **d. 流式传输 (Streaming):** 对于生成式建议，后端应使用**流式传输**（Streaming）将LLM的响应逐字或逐词返回给前端，前端也相应地流式显示灰色文字，以极大地降低感官上的等待时间。

**4. 云端与本地同步模式 (Cloud & Local Sync Mode):**
*   **目标:** 实现“离线优先 (Offline-First)”，确保数据安全和跨设备一致性。
*   **实现逻辑:**
    1.  **本地存储:** 在前端浏览器中使用 **IndexedDB** 作为本地数据库，完整存储用户的项目、知识库信息和所有文稿内容。推荐使用 `dexie.js` 库简化操作。
    2.  **数据流:** 用户的任何写入操作（新增文稿、修改内容）都首先写入本地IndexedDB，UI立即响应，提供零延迟的体验。
    3.  **上行同步 (Local to Cloud):** 一个后台服务工作者(Service Worker)会监听本地数据库的变更。当网络连接正常时，它会将变更队列中的操作通过Supabase API安全地推送到云端数据库。
    4.  **下行同步 (Cloud to Local):** 前端应用通过 `supabase-js` 客户端，订阅Supabase Realtime服务中与当前用户和项目相关的数据表。当云端数据因其他设备的操作而改变时，Supabase会主动推送消息，前端接收到后，会相应地更新本地IndexedDB和UI。
    5.  **冲突处理:** 在所有需要同步的表中使用 `updated_at` 时间戳字段。当发生同步冲突时（例如，离线修改了云端已被更新的数据），默认采用“最后写入者获胜”的简单策略来解决。

**5. 导出与分享模式 (Export & Share Mode):**
*   **导出功能:**
    *   **实现逻辑:** `.txt` 和 `.md` 的转换和下载可完全在前端通过JavaScript完成。对于 `.docx`，后端创建一个Supabase Edge Function，该函数接收文稿的JSONB内容，使用Deno的第三方库将其转换为Word文档格式，然后以文件流的形式返回给前端触发下载。
*   **分享功能:**
    *   **实现逻辑:** 用户点击分享时，后端为该文稿生成一个唯一的、加密安全的随机字符串`share_token`并存入`shared_documents`表。前端生成分享链接 `copytab.com/share/[share_token]`。当此链接被访问时，Next.js页面通过服务器端渲染（SSR）或客户端请求，使用`share_token`从数据库中获取文稿内容，并将其渲染在一个只读、无编辑功能的页面模板中。

**技术架构与选型 (Technical Architecture & Stack):**

*   **前端 (Frontend):** Next.js, TipTap, IndexedDB (`dexie.js`), `supabase-js`
*   **后端 (Backend):** Supabase (PostgreSQL with `pgvector` extension, Auto-generated API, Edge Functions, Auth, Realtime)
*   **AI模型 (AI Models):** Google AI (Gemini for generation/rewriting, Text Embedding Model for vectorization)

**数据库模型设计 (PostgreSQL Schema):**
注意：以下为初步规划，具体规划待完善！
```sql
-- 首先，确保在Supabase项目中启用了pgvector扩展
CREATE EXTENSION IF NOT EXISTS vector;

-- 项目表：每个项目是一个独立的知识库和文稿集合
CREATE TABLE projects (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    name TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 标准信息表 (用于逐字补全的条目式输入)
CREATE TABLE standard_info (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE NOT NULL,
    category TEXT, -- 可选分类，如“品牌”、“产品”、“法律”
    content TEXT NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT NOW() -- 用于冲突解决
);

-- 文稿表：存储用户撰写的实际内容
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE NOT NULL,
    title TEXT,
    content JSONB, -- 使用JSONB格式存储富文本内容 (TipTap的JSON输出)，便于未来扩展
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW() -- 用于冲突解决
);

-- (后台管理) 文档分块与向量表
CREATE TABLE document_chunks (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    project_id UUID REFERENCES projects(id) ON DELETE CASCADE NOT NULL,
    original_document_id UUID, -- 可选，关联原始上传文件
    content TEXT NOT NULL,
    embedding VECTOR(768) -- 维度取决于所用的嵌入模型
);
-- 为向量列创建索引以加速搜索
CREATE INDEX ON document_chunks USING ivfflat (embedding vector_l2_ops) WITH (lists = 100);

-- 分享文稿表：管理公开分享的链接
CREATE TABLE shared_documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE NOT NULL,
    share_token TEXT UNIQUE NOT NULL, -- 唯一的、随机的访问令牌
    access_level TEXT DEFAULT 'view' NOT NULL, -- 预留权限级别字段
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**团队协作架构冗余 (Architecture for Future Collaboration):**
*   **权限模型:** 在数据库设计阶段，预先构思一个 `project_members` 表，其结构为 (`project_id` UUID, `user_id` UUID, `role` TEXT)，其中 `role` 可以是 'owner', 'editor', 'viewer'。这将是未来实现团队共享和协作的基础。
*   **行级安全 (RLS):** 全面利用Supabase的PostgreSQL行级安全策略。为所有面向用户的表（`projects`, `standard_info`, `documents`等）编写RLS策略，确保用户只能访问和操作他们被明确授权的数据。例如，创建一个策略，规定只有`project_members`表中的用户才能访问对应`project_id`的资源。这是构建安全、多租户应用的最佳实践。